<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running a Laravel Website on a Live Server (Production)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #333;
        }
        pre {
            background: #eee;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
        .note {
            background-color: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 10px;
            margin: 15px 0;
        }
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin: 15px 0;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Notes on Running a Laravel Website on a Live Server (Production)</h1>

    <div class="note">
        <p><strong>Important:</strong> Deploying to a live server requires careful planning and a robust process. This guide provides a manual, general approach. For a more streamlined and automated process, consider using services like <strong>Laravel Forge</strong>, <strong>Envoyer</strong>, or platforms like <strong>Vapor</strong> for serverless deployments.</p>
    </div>

    <h2>Step 1: Server Setup (Prerequisites)</h2>
    <p>The prerequisites are similar to a test server, but with a heightened focus on security, performance, and stability.</p>
    <ul>
        <li><strong>Operating System:</strong> A stable, long-term support (LTS) version of a Linux distribution (e.g., Ubuntu LTS, CentOS Stream).</li>
        <li><strong>Web Server:</strong> Nginx is often preferred for its performance, but Apache is also a perfectly valid choice.</li>
        <li><strong>PHP:</strong> The latest stable version of PHP is recommended, along with a process manager like <strong>PHP-FPM</strong> for Nginx setups.</li>
        <li><strong>Database:</strong> A secure and performant database server (MySQL/MariaDB, PostgreSQL).</li>
        <li><strong>Composer & Git:</strong> Essential tools for dependency management and version control.</li>
        <li><strong>SSL/TLS Certificate:</strong> Crucial for security. Use a service like Let's Encrypt for free certificates.</li>
        <li><strong>Firewall:</strong> Configure a firewall (e.g., <code>ufw</code>) to only allow necessary traffic (SSH, HTTP, HTTPS).</li>
    </ul>

    <h2>Step 2: Project Deployment</h2>
    <p>Using Git is the most reliable and efficient method for deployment.</p>
    <ol>
        <li><strong>SSH into your server:</strong> Use a non-root user with sudo privileges.</li>
        <li><strong>Clone the repository:</strong> Navigate to your intended project directory (e.g., <code>/var/www/</code>) and clone your project.</li>
        <pre><code>git clone your_repo_url.git /var/www/your_project_name</code></pre>
        <li><strong>Set up a deployment script (Optional but recommended):</strong> A deployment script can automate tasks like pulling the latest code, running migrations, and clearing caches, ensuring a consistent and reliable deployment process.</li>
    </ol>
    
    <div class="warning">
        <p><strong>Warning:</strong> Never deploy directly from your local machine via FTP/SFTP to a live server. This can lead to inconsistent file states, missing dependencies, and security vulnerabilities.</p>
    </div>

    <h2>Step 3: Production Configuration</h2>
    <p>This is the most critical part of a live deployment. Do not use development settings on a live server.</p>
    <ol>
        <li><strong>Create a secure <code>.env</code> file:</strong></li>
        <ul>
            <li>Copy your <code>.env.example</code> file.</li>
            <pre><code>cp .env.example .env</code></pre>
            <li>Edit the <code>.env</code> file with <strong>production-specific</strong> values.</li>
            <pre><code>nano .env</code></pre>
            <li><strong>Crucial settings for production:</strong>
                <ul>
                    <li><code>APP_ENV=production</code></li>
                    <li><code>APP_DEBUG=false</code> (<strong>This is non-negotiable for security</strong>)</li>
                    <li><code>APP_URL=https://your_live_domain.com</code></li>
                    <li>Configure all database credentials, mail settings, and other services with their production values.</li>
                </ul>
            </li>
        </ul>

        <li><strong>Install Production Dependencies:</strong></li>
        <p>Use the <code>--no-dev</code> flag to prevent installing development dependencies, reducing the size and improving security.</p>
        <pre><code>composer install --no-dev --optimize-autoloader</code></pre>

        <li><strong>Generate the Application Key:</strong></li>
        <p>A new, unique key is essential for a new environment.</p>
        <pre><code>php artisan key:generate</code></pre>

        <li><strong>Optimize and Cache:</strong></li>
        <p>Laravel provides powerful caching commands to boost performance. Run these commands during your deployment process.</p>
        <pre><code>php artisan config:cache
php artisan route:cache
php artisan view:cache
php artisan event:cache</code></pre>
        <p><strong>Note:</strong> After caching, you must clear the cache and re-run these commands whenever you change your configuration, routes, or other cached files.</p>

        <li><strong>Run Database Migrations:</strong></li>
        <pre><code>php artisan migrate --force</code></pre>
        <p>The <code>--force</code> flag is necessary to bypass the production environment confirmation. Use it with caution, ideally within a deployment script that you have fully tested.</p>
    </ol>

    <h2>Step 4: Web Server Configuration (Live Domain)</h2>
    <p>The configuration is similar to the test server, but with a live domain and HTTPS in mind.</p>
    <h3>Nginx Example (Recommended for production):</h3>
    <p>Create a server block file (e.g., <code>/etc/nginx/sites-available/your_domain.com.conf</code>).</p>
    <pre><code>
server {
    listen 80;
    server_name your_live_domain.com www.your_live_domain.com;
    return 301 https://your_live_domain.com$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your_live_domain.com www.your_live_domain.com;
    root /var/www/your_project_name/public;

    ssl_certificate /etc/letsencrypt/live/your_live_domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your_live_domain.com/privkey.pem;

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";

    index index.php;
    charset utf-8;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }

    error_page 404 /index.php;

    location ~ \.php$ {
        fastcgi_pass unix:/var/run/php/php8.2-fpm.sock; # Adjust to your PHP version
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        include fastcgi_params;
    }

    location ~ /\.(?!well-known).* {
        deny all;
    }
}
    </code></pre>
    <p>Enable the site and restart Nginx.</p>
    <pre><code>sudo ln -s /etc/nginx/sites-available/your_domain.com.conf /etc/nginx/sites-enabled/
sudo nginx -t # Test configuration
sudo systemctl restart nginx</code></pre>

    <h2>Step 5: Permissions and Security</h2>
    <p>Set correct ownership and permissions to prevent unauthorized access and allow the web server to write to necessary directories.</p>
    <pre><code>sudo chown -R your_user:www-data /var/www/your_project_name
sudo chown -R www-data:www-data /var/www/your_project_name/storage
sudo chown -R www-data:www-data /var/www/your_project_name/bootstrap/cache
sudo chmod -R 775 /var/www/your_project_name/storage
sudo chmod -R 775 /var/www/your_project_name/bootstrap/cache</code></pre>
    <div class="note">
        <p><strong>Note:</strong> The first command sets ownership to your user, with the web server's user as the group. The subsequent commands give the web server (<code>www-data</code>) write access to the specific directories it needs.</p>
    </div>

    <h2>Step 6: Post-Deployment Best Practices</h2>
    <ul>
        <li><strong>Monitor Application Logs:</strong> Regularly check your Laravel log files (<code>storage/logs/laravel.log</code>) and web server logs for errors.</li>
        <li><strong>Set up a Queue Worker:</strong> For long-running tasks like sending emails or processing images, use a queue worker (e.g., Redis, Supervisor).</li>
        <li><strong>Implement Backups:</strong> Ensure you have a reliable, automated backup solution for both your application files and your database.</li>
        <li><strong>Scheduler Configuration:</strong> Set up the Laravel scheduler with a single cron job to run all scheduled tasks.</li>
        <pre><code>* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1</code></pre>
        <li><strong>Stay Updated:</strong> Keep your server's packages, PHP, and Laravel dependencies up to date with security patches.</li>
    </ul>

</div>

</body>
</html>